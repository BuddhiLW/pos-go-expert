#+title: Readme

* DONE Types and variables declaration
DEADLINE: <2023-12-04 Mon> SCHEDULED: <2023-12-04 Mon>

Alguma coisa

#+begin_src go
package main

import "fmt"


type ID int

var (b bool = true
	c int = 10
	d string = "Pedro"
	e float64 = 10.0
	f ID = 1)

const a = "Olá, mundo!"

func main() {
	fmt.Printf("Mensagem do fantasma da máquina: %v \n", a)
	fmt.Printf("O tipo criado pelo fantasma da máquina: %T \n", f)
	fmt.Printf("Exemplos de tipos nativos: %T %T %T %T", b, c, d, e)
}
#+end_src

#+RESULTS:
: Mensagem do fantasma da máquina: Olá, mundo!
: O tipo criado pelo fantasma da máquina: main.ID
: Exemplos de tipos nativos: bool int string float64

* DONE Structs and Interfaces
DEADLINE: <2023-12-06 Wed> SCHEDULED: <2023-12-06 Wed>

#+begin_src go :tangle ./fundacao/structs.go
package fundacao

import "fmt"

// Custom Type StruFoo
type StruFoo struct {
	S string
	I int
	B bool
}

// Composed custom type StruFooBar
type StruFooBar struct {
	SS []string
	II []int
	BB []bool
	StruFoo
}

// Custom type, StruBarfoo, relying on another Custom Type, StruFoo
type StruBarfoo struct {
	SS   []string
	II   []int
	BB   []bool
	SFoo StruFoo
}

func Structs() {
	struFoo := StruFoo{
		S: "Foo",
		I: 256,
		B: true,
	}

	struFooBar := StruFooBar{
		SS:      []string{"Foo", "Bar"},
		II:      []int{256, 512},
		BB:      []bool{true, false},
		StruFoo: struFoo,
	}

	struBarfoo := StruBarfoo{
		SS:   []string{"Foo", "Bar"},
		II:   []int{256, 512},
		BB:   []bool{true, false},
		SFoo: struFoo,
	}
	fmt.Printf("struFoo: %v %T \n", struFoo, struFoo)
	fmt.Printf("struFooBar: %v %T \n", struFooBar, struFooBar)
	fmt.Printf("struBarfoo: %v %T \n\n", struBarfoo, struBarfoo)

	fmt.Println("Struct instances of StruFooBar and StruBarfoo will look identical, but aren't.")
	fmt.Println("Composition vs Standard type (implies direct access vs not direct access):")
	fmt.Printf("struFooBar.S (%v) == struBarfoo.SFoo.S (%v)? %v", struFooBar.S, struBarfoo.SFoo.S, struFooBar.S == struBarfoo.SFoo.S)
}
#+end_src

#+begin_src shell :results verbatim
go run ./main.go
#+end_src

#+RESULTS:
: struFoo: {Foo 256 true} fundacao.StruFoo
: struFooBar: {[Foo Bar] [256 512] [true false] {Foo 256 true}} fundacao.StruFooBar
: struBarfoo: {[Foo Bar] [256 512] [true false] {Foo 256 true}} fundacao.StruBarfoo
:
: Struct instances of StruFooBar and StruBarfoo will look identical, but aren't.
: Composition vs Standard type (implies direct access vs not direct access):
: struFooBar.S (Foo) == struBarfoo.SFoo.S (Foo)? true
* DONE Interfaces
Interface structurally share =GCD= (Greatest Common Denominator) logic for Types.

The class =A={2, 6, 26}= all have different set of factors. But, GCD(A)=2. That is, every one of the members of A have a common factor 2 which makes them similar.

All of the elements of A can be divided by two. That's there common capability.

The same can be said of =Interface= _I_, which are those types which have an implemented _function_ =F1= among their capabilities.

#+begin_src go :tangle ./fundacao/interfaces.go
package fundacao

import "fmt"

// Interfaces
type I interface {
	F1()
}

func (s StruFoo) F1() {
	fmt.Printf("StruFoo prints itself: %v \n", s)
}

func (s StruFooBar) F1() {
	fmt.Printf("StruFooBar prints itself: %v \n", s)
}

func (s StruBarfoo) F1() {
	fmt.Printf("StruBarfoo print itself: %v \n", s)
}

func Interfaces() {
	struFoo := StruFoo{
		S: "Foo",
		I: 256,
		B: true,
	}

	struFooBar := StruFooBar{
		SS:      []string{"Foo", "Bar"},
		II:      []int{256, 512},
		BB:      []bool{true, false},
		StruFoo: struFoo,
	}

	struBarfoo := StruBarfoo{
		SS:   []string{"Foo", "Bar"},
		II:   []int{256, 512},
		BB:   []bool{true, false},
		SFoo: struFoo,
	}

	fmt.Println("Interfaces:")
	fmt.Println("If all Types X, Y, Z have the same capability of F1(), F2() etc., then they share the same Interface I := {X | exists F1(), F2() etc such that X.F1(), X.F2() etc. is valid}")

	var i I
	i = struFoo
	i.F1()
	i = struFooBar
	i.F1()
	i = struBarfoo
	i.F1()
}
#+end_src

* TODO Pointers and Variables
#+begin_src go :tangle ./fundacao/pointers-variables.go
package main

func main() {

}
#+end_src
